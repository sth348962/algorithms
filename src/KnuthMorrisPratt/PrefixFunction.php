<?php

namespace Sth348962\Algorithms\KnuthMorrisPratt;

class PrefixFunction
{
    /**
     * @param string $s Строка символов в кодировке ASCII, для которых вычисляется значение префикс-функции
     * @return int[]
     */
    public function get(string $s): array
    {
        $p = [0];
        $len = strlen($s);

        for ($i = 1; $i < $len; $i++) {
            $j = $p[$i - 1];

            while ($j > 0 && $s[$i] !== $s[$j]) {
                //
                // Префикс X     /--------------\         /--------------\
                //              |                |       |                |
                // Префикс Y    |^              ^|       |^              ^|
                //              | |            | |       | |            | |
                // Префикс Z    |/|---\        | |       | |            |/|---\
                //              | |    |       | |       | |            | |    |
                // Строка S    [ A ][ B ][ C ][ A ][ C ][ A ][ B ][ C ][ A ][ B ]
                // Шаги (0-9)  [ 0 ][ 1 ][ 2 ][ 3 ][ 4 ][ 5 ][ 6 ][ 7 ][ 8 ][ 9 ]
                // Значения ПФ [ 0 ][ 0 ][ 0 ][ 1 ][ 0 ][ 1 ][ 2 ][ 3 ][ 4 ][ 2 ]
                //
                // Для строки S получаем значение префикс-функции P для шага i (P[i] = X = 4, шаг i = 8).
                // На шаге i+1 смотрим, совпадает ли элемент, добавляемый к концу строки (S[9] = B),
                // с элементом, добавляемым к концу префикса шага i (S[P[8]] = S[4] = C).
                // Если совпадает (C == B), то значение префикс-функции для шага i+1
                // P[i+1] = P[i]+1
                // Если не совпадает (C != B), то нам нужно найти в массиве значений префикс-функции для
                // предыдущих шагов (т.е. P[0...i-1]) такой максимальный префикс, который будет заканчиваться
                // тем же элементом, на который заканчивался собственный суффикс шага i (т.е. S[i]).
                // Т.е. нужно найти значение префикс-функции для собственного суффикса шага i, т.е.
                // найти j = P[P[i]-1] (минус 1, т.к. нумерация шагов начинается с нуля, а значение префикс-функции -
                // это длина строки, т.е. j = P[P[8]-1] = P[3] = Y = 1).
                // Дальше сравниваем следующий за префиксом j символ (S[j]) с символом, добавляемым к концу строки (S[9]).
                // Если они равны, то
                // P[i+1] = j+1 (P[9] = Z = 2)
                // Иначе - продолжаем с момента значения префикс-функции для собственного суффикса шага j-1.
                // И так до момента, пока не найдём подходящее значение, или не наткнемся ну нулевое значение префикс функции.
                // Если наткнулись на нулевое значение префикс-функции, то сравниваем S[0] и S[i+1].
                // Если равны, то P[i+1] = 1, иначе 0.
                $j = $p[$j - 1];
            }

            if ($s[$i] === $s[$j]) {
                $j++;
            }

            $p[$i] = $j;
        }

        return $p;
    }
}